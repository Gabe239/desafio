import fs from "fs";
import Product from '../dao/models/productModel.js';

class ProductManager {
  constructor(path) {
    this.path = path;
    this.id = 1;
  }

  findMissingProductId() {
    const ids = this.products.map(product => product.id);
    const maxId = this.products.length;

    for (let i = 1; i <= maxId; i++) {
      if (!ids.includes(i)) {
        return i;
      }
    }
    return this.products.length + 1;
  }

  async addProduct(title, description, price, thumbnail, code, stock) {
    try {

      this.products = await this.getProducts();

      if (!title || !description || !price || !thumbnail || !code || !stock) {
        throw new Error("Faltan datos para completar la adici칩n del producto");
      }

      if (
        typeof title !== "string" ||
        typeof description !== "string" ||
        typeof thumbnail !== "string" ||
        typeof price !== "number" ||
        typeof code !== "string" ||
        typeof stock !== "number"
      ) {
        throw new Error(
          "Los datos proporcionados no son v치lidos para la adici칩n del producto"
        );
      }

      if (this.products.find(product => product.code === code)) {
        throw new Error("El c칩digo se repite");
      }

      const newProduct = {
        title,
        description,
        price,
        thumbnail,
        code,
        stock,
        id: this.findMissingProductId()
      };

      this.products.push(newProduct);

      await fs.promises.writeFile(this.path, JSON.stringify(this.products, null, "\t"), "utf-8");

      console.log("Los productos han sido guardados correctamente.");
    } catch (err) {
      throw new Error("Error al guardar los productos: " + err.message);
    }
  }

  async getProducts() {
    try {
      const data = await fs.promises.readFile(this.path, "utf-8");
      this.products = JSON.parse(data);
      return this.products;
    } catch (err) {
      throw new Error("Error al leer el archivo: " + err.message);
    }
  }

  async getProductById(id) {
    try {
      const data = await fs.promises.readFile(this.path, "utf-8");
      const products = JSON.parse(data);
      const productById = products.find(product => product.id == id);
      if (!productById) {
        throw new Error("Product not found");
      }
      return productById;
    } catch (err) {
      throw new Error("Error al leer el archivo: " + err.message);
    }
  }

  async updateProduct(title, description, price, thumbnail, code, stock, id) {
    try {
      this.products = await this.getProducts();
      const index = this.products.findIndex(product => product.id == id);
      this.products[index] = {
        title: title,
        description: description,
        price: price,
        thumbnail: thumbnail,
        code: code,
        stock: stock,
        id: id
      };

      await fs.promises.writeFile(
        this.path,
        JSON.stringify(this.products, null, "\t"),
        "utf-8"
      );

      console.log("El producto ha sido actualizado correctamente.");
    } catch (err) {
      throw new Error("Error actualizando el producto: " + err.message);
    }
  }

  async deleteProduct(id) {
    try {
      await this.getProducts();
      const index = this.products.findIndex(product => product.id == id);
      this.products.splice(index, 1);

      await fs.promises.writeFile(
        this.path,
        JSON.stringify(this.products, null, "\t"),
        "utf-8"
      );

      console.log("El producto ha sido eliminado correctamente.");
    } catch (err) {
      throw new Error("Error eliminando el producto: " + err.message);
    }
  }
}




import express from 'express';
const router = express.Router();

import ProductManager from '../ProductManager.js';
const productManager = new ProductManager('./data.json');

import { io } from '../app.js';

router.get("/", async (req, res) => {
  try {
    const limit = parseInt(req.query.limit);
    const products = await productManager.getProducts();

    if (!isNaN(limit)) {
      return res.status(200).json(products.slice(0, limit));
    } else {
      return res.status(200).json(products);
    }
  } catch (err) {
    return res.status(500).json({ error: 'Error al enviar los productos' });
  }
});

router.get('/:pid', async (req, res) => {
  try {
    const productId = parseInt(req.params.pid);
    const product = await productManager.getProductById(productId);

    if (product) {
      return res.status(200).json(product);
    } else {
      return res.status(404).json({ error: 'Producto no encontrado' });
    }
  } catch (err) {
    return res.status(500).json({ error: 'Error al enviar los productos' });
  }
});

router.post('/', async (req, res) => {

  const newProduct = req.body;
  

  try {
    console.log(newProduct);
    await productManager.addProduct(
      newProduct.title,
      newProduct.description,
      newProduct.price,
      newProduct.thumbnail,
      newProduct.code,
      newProduct.stock
    );

    io.emit("product-added", newProduct);

    return res.status(201).json(newProduct);
  } catch (error) {
    return res.status(500).json({ error: 'Error al agregar el producto' });
  }
});

router.put('/:pid', async (req, res) => {
  try {
    const productIdStr = req.params.pid;
    const updatedProduct = req.body;
    const productId = parseInt(productIdStr);
    const product = await productManager.getProductById(productId);

    if (product) {
      const { title, description, price, thumbnail, code, stock } = updatedProduct;
      await productManager.updateProduct(
        title,
        description,
        price,
        thumbnail,
        code,
        stock,
        productId
      );
      io.emit("product-updated", product);
      return res.status(200).json({ ...product, ...updatedProduct });
    } else {
      return res.status(404).json({ error: 'Producto no encontrado' });
    }
  } catch (error) {
    return res.status(500).json({ error: 'Error al actualizar el producto' });
  }
});

router.delete('/:pid', async (req, res) => {
  try {
    const productId = req.params.pid;
    const product = await productManager.getProductById(productId);

    if (product) {
      await productManager.deleteProduct(productId);
      io.emit("product-deleted", product);
      return res.status(200).json(product);
    } else {
      return res.status(404).json({ error: 'Producto no encontrado' });
    }
  } catch (error) {
    return res.status(500).json({ error: 'Error al eliminar el producto' });
  }
});

export default router;
import { Router } from 'express';

import ProductManager from '../dao/managers/ProductManager.js';
const productManager = new ProductManager('./data.json');

const router = Router();

router.get('/', async (req, res) => {
    let products = await productManager.getProducts();
    return res.render('home', {
        title: 'Home',
        products: products
    })
});

router.get('/realtimeproducts', async (req, res) => {
    const products = await productManager.getProducts();

    return res.render("realTimeProducts", {
        title: "Real Time Products",
        products: products,
    });


});

export default router;










import express from 'express';
const router = express.Router();

import Product from '../ProductManager.js';


import { io } from '../app.js';





router.get('/', async (req, res) => {
  try {
    const limit = parseInt(req.query.limit);
    let products;

    if (!isNaN(limit)) {
      products = await Product.find().limit(limit);
    } else {
      products = await Product.find();
    }

    return res.status(200).json(products);
  } catch (err) {
    return res.status(500).json({ error: 'Error al enviar los productos' });
  }
});

router.get('/:pid', async (req, res) => {
  try {
    const productId = req.params.pid;
    const product = await Product.findById(productId);

    if (product) {
      return res.status(200).json(product);
    } else {
      return res.status(404).json({ error: 'Producto no encontrado' });
    }
  } catch (err) {
    return res.status(500).json({ error: 'Error al enviar los productos' });
  }
});

router.post('/', async (req, res) => {
  const newProduct = req.body;

  try {
    const createdProduct = await Product.create(newProduct);

    io.emit('product-added', createdProduct);

    return res.status(201).json(createdProduct);
  } catch (error) {
    return res.status(500).json({ error: 'Error al agregar el producto' });
  }
});

router.put('/:pid', async (req, res) => {
  try {
    const productId = req.params.pid;
    const updatedProduct = req.body;

    const product = await Product.findByIdAndUpdate(productId, updatedProduct, {
      new: true,
    });

    if (product) {
      io.emit('product-updated', product);
      return res.status(200).json(product);
    } else {
      return res.status(404).json({ error: 'Producto no encontrado' });
    }
  } catch (error) {
    return res.status(500).json({ error: 'Error al actualizar el producto' });
  }
});

router.delete('/:pid', async (req, res) => {
  try {
    const productId = req.params.pid;
    const product = await Product.findByIdAndDelete(productId);

    if (product) {
      io.emit('product-deleted', product);
      return res.status(200).json(product);
    } else {
      return res.status(404).json({ error: 'Producto no encontrado' });
    }
  } catch (error) {
    return res.status(500).json({ error: 'Error al eliminar el producto' });
  }
});

export default router;